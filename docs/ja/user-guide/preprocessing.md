# 前処理ガイド

ラマンスペクトルの包括的な前処理テクニック

---

## 📋 目次

- {ref}`前処理の重要性 <ug-preprocess-importance>`
- {ref}`前処理パイプライン <ug-preprocess-pipeline>`
- {ref}`ベースライン補正 <ug-preprocess-baseline>`
- {ref}`スムージング <ug-preprocess-smoothing>`
- {ref}`正規化 <ug-preprocess-normalization>`
- {ref}`微分 <ug-preprocess-derivatives>`
- {ref}`高度な手法 <ug-preprocess-advanced>`
- {ref}`パイプライン最適化 <ug-preprocess-optimization>`
- {ref}`ケーススタディ <ug-preprocess-case-study>`

---

(ug-preprocess-importance)=
## 前処理の重要性

### なぜ前処理が必要か

ラマンスペクトルには以下のような問題が含まれることがあります:

#### 1. 蛍光バックグラウンド

```
問題:
サンプルの蛍光により、ラマンピークの上に
大きなブロードなバックグラウンド信号が重なる

影響:
- ピークが見えにくい
- 定量分析が不正確
- パターン認識が困難

解決策:
→ ベースライン補正（AsLS、AirPLS）
```

#### 2. ノイズ

```
問題:
測定中のランダムな変動（電子ノイズ、光子ノイズ）

影響:
- スペクトルがギザギザ
- ピーク検出が困難
- 微小な差の検出が不可能

解決策:
→ スムージング（Savitzky-Golay、Gaussian）
```

#### 3. スケールの違い

```
問題:
測定条件の違いにより、スペクトルの全体的な
強度が異なる

影響:
- サンプル間の比較が困難
- 機械学習モデルが不安定
- 統計分析が不適切

解決策:
→ 正規化（ベクトルノルム、SNV、MSC）
```

#### 4. オフセット

```
問題:
ベースライン全体がシフトしている

影響:
- 負の値が出現
- 比較が困難

解決策:
→ ベースラインシフト、最小値減算
```

### 前処理の効果

#### 前処理前

```
スペクトル特徴:
- 大きなバックグラウンド（0-1000 a.u.）
- ノイズレベル高い（SNR < 20）
- ピークが埋もれている
- サンプル間の強度差が大きい

分析の問題:
- PCA: 最初の2成分で30%の説明分散のみ
- クラスタリング: グループ分離が不明確
- 機械学習: 精度 60-70%
```

#### 前処理後

```
スペクトル特徴:
- フラットなベースライン（0付近）
- ノイズレベル低い（SNR > 50）
- ピークが明確
- スケールが統一

分析の改善:
- PCA: 最初の2成分で70-80%の説明分散
- クラスタリング: 明確なグループ分離
- 機械学習: 精度 85-95%
```

---

(ug-preprocess-pipeline)=
## 前処理パイプライン

### パイプラインの構築

#### 基本的な流れ

```
1. 品質チェック
   ↓
2. ベースライン補正
   ↓
3. スムージング
   ↓
4. 正規化
   ↓
5. （オプション）微分
   ↓
6. 結果の検証
```

### UIでのパイプライン構築

```
前処理タブ → パイプライン構築:

1. 「手法を追加」をクリック
2. カテゴリから選択
3. パラメータを設定
4. プレビューで確認
5. 「適用」をクリック
```

### プレビュー機能の使用

```
パイプライン構築中:

表示:
- 青線: 元のスペクトル
- 緑線: 現在のステップ後
- 赤線: 最終結果

インタラクティブ:
- パラメータをスライダーで調整
- リアルタイムで結果を確認
- 最適な値を探索
```

---

(ug-preprocess-baseline)=
## ベースライン補正

### AsLS（Asymmetric Least Squares）

#### 原理

```
最小二乗法により滑らかなベースラインをフィッティング
非対称な重みにより、ピークの影響を最小化

目的関数:
minimize: Σ w_i(y_i - z_i)² + λ Σ (Δ²z_i)²

w_i: 重み（ピークには小さい重み）
z_i: ベースライン
λ: 平滑化パラメータ
Δ²z_i: 2階差分（滑らかさのペナルティ）
```

#### パラメータ

**lambda（λ）: 平滑化パラメータ**

```
小さい値（10² - 10³）:
- ピークに追従
- 狭い変動に適応
- 用途: 局所的なベースライン変動

中程度（10⁴ - 10⁵）:
- 標準的な使用
- バランスが良い
- 用途: ほとんどのラマンスペクトル

大きい値（10⁶ - 10⁸）:
- 非常に滑らか
- 広いバックグラウンド
- 用途: 強い蛍光バックグラウンド
```

**p: 非対称性パラメータ**

```
小さい値（0.001 - 0.01）:
- ピークを強く保護
- 用途: ピークがベースライン上に明確にある

中程度（0.05 - 0.1）:
- バランスが取れている
- 用途: 一般的なスペクトル

大きい値（0.1 - 0.5）:
- より強い補正
- 用途: 大きなドリフトがある場合
```

#### 実用例

**ケース1: 標準的なラマンスペクトル**
```
設定:
lambda = 100000（10⁵）
p = 0.01
max_iter = 10

期待される結果:
- 滑らかなベースライン
- ピーク形状の保持
- 計算時間 < 1秒
```

**ケース2: 強い蛍光バックグラウンド**
```
設定:
lambda = 1000000（10⁶）
p = 0.001
max_iter = 15

期待される結果:
- 非常に滑らかなベースライン
- ブロードなバックグラウンド除去
- シャープなピークの保護
```

**ケース3: 小さな局所変動**
```
設定:
lambda = 10000（10⁴）
p = 0.05
max_iter = 10

期待される結果:
- ベースラインが局所的な変動に追従
- 狭い範囲のドリフト補正
```

### AirPLS（Adaptive Iteratively Reweighted Penalized Least Squares）

#### AsLSとの違い

```
AirPLS:
✓ 自動的に重みを調整
✓ パラメータが少ない
✓ より適応的
✗ やや遅い

AsLS:
✓ 高速
✓ よく研究されている
✗ pパラメータの調整が必要
```

#### パラメータ

```
lambda: AsLSと同様の平滑化パラメータ
  推奨: 100000 - 1000000

porder: ペナルティの次数
  通常: 2（2階微分）

max_iter: 最大反復回数
  推奨: 15 - 30
```

#### 使用例

```
前処理 → ベースライン補正 → AirPLS:

lambda: 500000
porder: 2
max_iter: 20

適用ケース:
- AsLSで調整が困難な場合
- 複雑なベースライン形状
- より自動化された処理が必要
```

### Whittaker Smoother

#### 特徴

```
利点:
✓ 非常に高速
✓ 大規模データに適する
✓ 実装がシンプル

欠点:
✗ ピークが大きい場合、影響を受けやすい
```

#### パラメータ

```
lambda: 平滑化パラメータ
  推奨: 1000 - 100000
  
用途:
- 計算速度が重要
- ピークが小さい
- ベースライン変動が滑らか
```

---

(ug-preprocess-smoothing)=
## スムージング

### Savitzky-Golay フィルタ

#### 原理

```
局所的に多項式をフィッティングし、中心点の値を予測

利点:
✓ ピーク形状を保持
✓ 微分と同時に実行可能
✓ 計算が高速

欠点:
✗ エッジ効果（端の処理）
```

#### パラメータ

**window_length: ウィンドウサイズ**

```
小さい（5-7）:
- ノイズ除去は控えめ
- ピーク形状をよく保持
- 用途: 高品質データ、シャープなピーク

中程度（9-15）:
- バランスが良い
- 一般的な使用
- 用途: ほとんどのラマンスペクトル

大きい（17-31）:
- 強いスムージング
- ピークが広がる可能性
- 用途: ノイズが多いデータ、ブロードなピーク
```

**polyorder: 多項式の次数**

```
1次（線形）:
- 最も滑らか
- ピークの詳細が失われる

2-3次（推奨）:
- ピーク形状を保持
- ノイズも除去

4次以上:
- 細かい構造を保持
- ノイズ除去が弱い
```

#### 経験則

```
ウィンドウサイズの選択:
window_length ≈ ピーク幅の 1/3 〜 1/2

例:
ピーク幅が30ポイント → window = 9-15
ピーク幅が10ポイント → window = 5-7
```

#### 実用例

**高品質データ**
```
window_length = 7
polyorder = 2

結果: 軽いスムージング、詳細保持
```

**標準的なデータ**
```
window_length = 11
polyorder = 3

結果: バランスの取れたスムージング
```

**ノイズの多いデータ**
```
window_length = 15
polyorder = 2

結果: 強いノイズ除去、ピーク保持
```

### Gaussian スムージング

#### 原理

```
ガウシアンカーネルによる畳み込み

カーネル: exp(-x²/(2σ²))

利点:
✓ 非常に滑らか
✓ 周波数領域での良好な特性

欠点:
✗ ピークが広がる
✗ Savitzky-Golayより詳細が失われる
```

#### パラメータ

```
sigma: ガウシアンの標準偏差

小さい（0.5-1.0）:
- 軽いスムージング
- 詳細保持

中程度（1.5-3.0）:
- 標準的な使用
- バランスが良い

大きい（3.5-5.0）:
- 強いスムージング
- ピークが広がる
```

#### 使用例

```
前処理 → スムージング → Gaussian:

sigma = 2.0

適用ケース:
- 全体的に滑らかにしたい
- ピークの正確な形状が重要でない
- 視覚化目的
```

### Moving Average

#### 特徴

```
最もシンプルなスムージング

利点:
✓ 非常に高速
✓ 理解しやすい

欠点:
✗ エッジがシャープ
✗ Savitzky-Golayより性能が劣る
```

#### パラメータ

```
window_size: 移動平均のウィンドウ

推奨: 5-15

用途:
- 高速処理が必要
- 大規模データ
```

---

(ug-preprocess-normalization)=
## 正規化

### ベクトルノルム（L2正規化）

#### 原理

```
スペクトルベクトルの長さを1に正規化

normalized_spectrum = spectrum / ||spectrum||₂

ここで:
||spectrum||₂ = √(Σ intensity_i²)

効果:
- 全体的な強度の違いを除去
- 形状情報を保持
```

#### 使用例

```
前処理 → 正規化 → ベクトルノルム

適用ケース:
- 探索的データ分析（PCA、UMAP）
- 形状に基づく比較
- 機械学習の前処理
```

### SNV（Standard Normal Variate）

#### 原理

```
各スペクトルを平均0、標準偏差1に標準化

SNV = (spectrum - mean(spectrum)) / std(spectrum)

効果:
- スケールとオフセットを除去
- 散乱の影響を低減
```

#### 使用例

```
前処理 → 正規化 → SNV

適用ケース:
- NIRスペクトル
- 散乱による変動が大きい
- 定量分析
```

### MSC（Multiplicative Scatter Correction）

#### 原理

```
基準スペクトルに対して線形回帰を実行し、
傾きとオフセットを補正

spectrum_corrected = (spectrum - b) / a

a: 傾き
b: オフセット

効果:
- 散乱の影響を補正
- 粒子サイズの影響を低減
```

#### パラメータ

```
reference: 基準スペクトル
  - 平均スペクトル（推奨）
  - 特定のサンプル
  - 理論的なスペクトル
```

#### 使用例

```
前処理 → 正規化 → MSC:

reference = 'mean'（平均スペクトル）

適用ケース:
- 粉末サンプル
- 散乱の影響が大きい
- 定量分析
```

### Min-Max 正規化

#### 原理

```
最小値を0、最大値を1にスケーリング

normalized = (spectrum - min) / (max - min)

効果:
- すべてのスペクトルが0-1の範囲
- 視覚化に適する
```

#### 使用例

```
前処理 → 正規化 → Min-Max

適用ケース:
- 視覚化
- ニューラルネットワークの入力
- 単純な比較
```

### 最大値正規化

#### 原理

```
最大ピークを1に正規化

normalized = spectrum / max(spectrum)

効果:
- 最大ピークの高さが統一
- 相対強度の比較
```

#### 使用例

```
前処理 → 正規化 → 最大値

適用ケース:
- 主要ピークの比較
- 定性分析
- 相対強度の評価
```

---

(ug-preprocess-derivatives)=
## 微分

### 一次微分

#### 原理

```
スペクトルの傾きを計算

d(spectrum)/d(wavenumber)

効果:
- ベースラインの傾きを除去
- 重なったピークの分離
- ピークが谷に変換
```

#### パラメータ（Savitzky-Golay微分）

```
window_length: 9-15（推奨）
polyorder: 2-3
deriv: 1（一次微分）
```

#### 使用例

```
前処理 → 微分 → 一次微分（SG）:

window_length = 11
polyorder = 3
deriv = 1

適用ケース:
- ベースライン傾きの除去
- 重なったピークの分離
- 微小な差の強調
```

#### 注意点

```
注意:
- ノイズが増幅される
- 微分の前にスムージングが必須
- ピーク強度情報が失われる

推奨パイプライン:
1. ベースライン補正
2. スムージング
3. 正規化
4. 微分
```

### 二次微分

#### 原理

```
一次微分の微分

d²(spectrum)/d(wavenumber)²

効果:
- ピークが負のピークに
- シャープな特徴が強調
- さらにノイズが増幅
```

#### 使用例

```
前処理 → 微分 → 二次微分（SG）:

window_length = 13
polyorder = 3
deriv = 2

適用ケース:
- 非常に重なったピークの分離
- ピーク位置の正確な決定
- 肩ピークの検出
```

---

(ug-preprocess-advanced)=
## 高度な手法

### EMSC（Extended Multiplicative Signal Correction）

#### 特徴

```
MSCの拡張版

追加の補正:
- 物理的な散乱モデル
- 干渉成分の除去
- 非線形効果の補正

利点:
✓ より正確な補正
✓ 物理的な解釈

欠点:
✗ より複雑
✗ パラメータが多い
```

### FABC（Fast Adaptive Baseline Correction）

#### 特徴

```
高速な適応的ベースライン補正

利点:
✓ 非常に高速
✓ 大規模データに適する
✓ パラメータが少ない

用途:
- リアルタイム処理
- バッチ処理
- 探索的分析
```

### CDAE（Convolutional Denoising Autoencoder）

#### 特徴

```
深層学習ベースのノイズ除去

利点:
✓ 非常に効果的
✓ 複雑なノイズパターンに対応
✓ 自動的に学習

欠点:
✗ 学習データが必要
✗ 計算コストが高い
✗ GPUが推奨される

用途:
- 非常にノイズの多いデータ
- 従来の手法で不十分な場合
```

---

(ug-preprocess-optimization)=
## パイプライン最適化

### 一般的なパイプライン

#### パイプライン1: 探索的分析用

```
目的: PCA、クラスタリング、可視化

1. AsLS（ベースライン補正）
   lambda: 100000
   p: 0.01

2. Savitzky-Golay（スムージング）
   window: 11
   polyorder: 3

3. ベクトルノルム（正規化）

期待される結果:
- クリーンなスペクトル
- ピーク形状保持
- スケール統一
```

#### パイプライン2: 定量分析用

```
目的: 濃度予測、検量線

1. AsLS（ベースライン補正）
   lambda: 100000
   p: 0.01

2. MSC（散乱補正）
   reference: 'mean'

3. SNV（標準化）

期待される結果:
- 散乱の影響除去
- 再現性の向上
- 予測精度向上
```

#### パイプライン3: 分類・識別用

```
目的: 機械学習による分類

1. AsLS（ベースライン補正）
   lambda: 100000
   p: 0.01

2. Savitzky-Golay（スムージング）
   window: 11
   polyorder: 3

3. ベクトルノルム（正規化）

4.（オプション）一次微分
   window: 11
   polyorder: 3

期待される結果:
- 微小な差の強調
- 分類精度向上
```

### パラメータの調整

#### 体系的アプローチ

```
ステップ1: 品質評価
現在のデータを評価:
- SNR
- ベースラインの安定性
- ピークの明確さ

ステップ2: 主要な問題を特定
優先順位:
1. 大きなバックグラウンド → ベースライン補正
2. ノイズ → スムージング
3. スケールの違い → 正規化

ステップ3: 段階的調整
1つずつパラメータを調整:
1. デフォルト値で開始
2. プレビューで確認
3. 必要に応じて調整
4. 次の手法へ

ステップ4: 検証
最終結果を評価:
- ベースラインがフラットか
- ピークが保持されているか
- ノイズが減少したか
```

#### グリッドサーチ

複数のパラメータ組み合わせを試す:

```python
# lambda の探索
lambdas = [10000, 50000, 100000, 500000, 1000000]

# window の探索
windows = [7, 9, 11, 13, 15]

# 各組み合わせを評価
for lambda_val in lambdas:
    for window in windows:
        # パイプラインを適用
        # 結果を評価
        # 最適な組み合わせを記録
```

### 結果の評価

#### 視覚的評価

```
確認項目:
□ ベースラインが0付近でフラット
□ ピーク形状が保持されている
□ ノイズレベルが低い
□ 人工的なアーチファクトがない
□ すべてのサンプルで一貫している
```

#### 定量的評価

```
メトリクス:
1. SNR（信号対雑音比）
   SNR = ピーク高さ / ノイズ標準偏差
   目標: SNR > 50

2. ベースライン平坦度
   標準偏差 < 0.01

3. ピーク検出数
   主要ピークがすべて検出される

4. スペクトル間の類似度
   同じグループ内で類似度 > 0.95
```

---

(ug-preprocess-case-study)=
## ケーススタディ

### ケース1: 強い蛍光バックグラウンド

#### 問題

```
元のスペクトル:
- 大きなブロードなバックグラウンド（0-1000 a.u.）
- ラマンピークが埋もれている
- 傾きも大きい
```

#### 解決策

```
パイプライン:

1. AirPLS（強い補正）
   lambda: 1000000
   porder: 2
   max_iter: 20

2. Savitzky-Golay
   window: 11
   polyorder: 3

3. ベクトルノルム

結果:
- フラットなベースライン
- ピークが明確に見える
- SNR改善: 15 → 60
```

### ケース2: 非常にノイズが多いデータ

#### 問題

```
元のスペクトル:
- SNR < 10
- ピークがノイズに埋もれている
- ギザギザが激しい
```

#### 解決策

```
パイプライン:

1. AsLS
   lambda: 100000
   p: 0.01

2. Savitzky-Golay（強いスムージング）
   window: 15
   polyorder: 2

3. Gaussian（追加スムージング）
   sigma: 1.5

4. ベクトルノルム

結果:
- 滑らかなスペクトル
- 主要ピークが明確
- SNR改善: 8 → 35
```

### ケース3: 粉末サンプル（散乱が大きい）

#### 問題

```
元のスペクトル:
- サンプル間で強度が大きく異なる
- 粒子サイズの影響
- 散乱による変動
```

#### 解決策

```
パイプライン:

1. AsLS
   lambda: 100000
   p: 0.01

2. Savitzky-Golay
   window: 11
   polyorder: 3

3. MSC（散乱補正）
   reference: 'mean'

4. SNV（標準化）

結果:
- スケールが統一
- 散乱の影響が除去
- サンプル間の比較可能性向上
```

### ケース4: 微小な差の検出

#### 問題

```
目的:
非常に似たサンプル間の微小な差を検出

困難:
- ピークがほぼ重なっている
- 差がわずか（< 5%）
```

#### 解決策

```
パイプライン:

1. AsLS
   lambda: 100000
   p: 0.01

2. Savitzky-Golay
   window: 9
   polyorder: 3

3. ベクトルノルム

4. 一次微分
   window: 11
   polyorder: 3
   deriv: 1

結果:
- 微小な差が強調
- 重なったピークが分離
- 分類精度向上: 65% → 88%
```

---

## 🔗 関連ドキュメント

- **[データ管理](importing-data.md)** - データのインポート
- **[分析手法](../analysis-methods/index.md)** - 分析方法
- **[機械学習](machine-learning.md)** - MLモデル構築
- **[FAQ](../faq.md)** - よくある質問

---

**最終更新**: 2026年1月24日 | **バージョン**: 1.0.0
